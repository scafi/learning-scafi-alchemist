# Simulations with Alchemist and Scafi: tutorial

This tutorial presents a sequence of increasingly rich examples using the [Scafi aggregate programming DSL](https://scafi.github.io) and [the Alchemist Simulator](https://alchemistsimulator.github.io/).

## Requirements

A [Gradle-compatible Java version](https://docs.gradle.org/current/userguide/compatibility.html) -- link to temurin

**Check if it works** `java -version`

Git

## Quickstart

Here, a one-liner command + explanation of the GUI + animated gif of the expected result
+ gui instructions -> https://alchemistsimulator.github.io/reference/default-ui/
(windows version?? we can test with guacamole on the labs)

### What happened

* download repo
* creation folder xxx
* command uiiuiii executed inside xxx

* Network of devices
* colors based on ...
* the simulator runs the program every x seconds
* the interaction among devices builds the distributed data structure

**Something wrong?**

Try the following:
1. clone manually using ...
    1. alternatively: download zip 
    3. unzip
4. open a terminal insid zip
5. run ...

## Guided examples

from now on, we will assume all commands have been issued inside xxx

### Hello, Scafi! A gradient in space and time

0. command
1. what happened
2. what is inside
3. minimal change

### Using the generated data with the embedded plotting script

To run all the (graphic) simulations defined in src/main/yaml type:

```bash
$ ./gradlew runAll
```
To run the simulation in batch (e.g, to produce data for plots) you can type:
```bash
$ ./gradlew runAll -Pbatch=true -Pvariables=random
```

### A richer pattern: Self-organizing Coordination Regions

as above + link to the paper

### Overlapping computations in space and time with aggregate processes

...

## External resources to improve your understanding

The Alchemist metamodel https://alchemistsimulator.github.io/explanation/
The Alchemist Simulator reference https://alchemistsimulator.github.io/reference/yaml/
same for scafi


<!--

### Conceptual model

- **Molecule**: name of a data item
- **Concentration**: value associated to a particular molecule
- **Node**: a container of molecules/reactions, living inside an environment
- **Environment**: the Alchemist abstration for the space.
    - It is a container for nodes, and it is able to tell:
  a) Where the nodes are in the space - i.e. their position
  b) How distant are two nodes
  c) Optionally, it may provide support for moving nodes
- **Linking rule**: a function of the current status of the environment that associates to each node a
  neighborhood
    - **Neighborhood**: an entity composed by a node (centre) + a set of nodes (neighbors)
- **Reaction**: any event that can change (through an **action**) the state of the environment
    - Consists of 0+ **conditions**, 1+ **actions**, and a **time distribution**
    - Conditions, time distribution, static rate, and rate equation affect the **frequency** of the reaction
- Alchemist implements an optimised version (NRM) of Gillespie's Stochastic Simulation Algorithm (SSA)

So

- The **system state** depends on the configuration of molecules floating in it
- The **system evolution** depends on the kinds of chemical reactions applicable over time

Another key concept is the **dependency graph**

- Actions are outputs
- Conditions are inputs

### Running simulations




Finally, you can produce plots from the data generated by Alchemist simulation.
This repository contains a highly configurable script (please look to the configuration defined in [plots](/plots)).

To run the script, you should run:
```bash
$ python plotter.py plots/helloworld.yml ./build/exports/helloScafi ".*" "result" plots/ 
```

Where:
- the first argument is the plot configuration (expressed using a yaml file)
- the second argument is where the files are located 
- the third argument is a regex used to select the simulations file
- the fourth argument defines the initial names of the plot
- the last argument devises the folder in which the plots will be stored
### Scafi

The simulation descriptor must indicate `incarnation: scafi`
 and configure a `RunScafiProgram` action
 pointing to the class of some class implementing `AggregateProgram`.

```yaml
incarnation: scafi

_reactions:
  - program: &program
    - time-distribution:
        type: ExponentialTime
        parameters: [1]
      type: Event
      actions:
        - type: RunScafiProgram
          parameters: [it.unibo.casestudy.HelloWorld, 5.0] # second argument is retention time
    - program: send
```
An example ScaFi program is the following

```scala
package it.unibo.casestudy

import it.unibo.alchemist.model.implementations.molecules.SimpleMolecule
import it.unibo.alchemist.model.scafi.ScafiIncarnationForAlchemist._

class HelloWorld extends AggregateProgram with StandardSensors with ScafiAlchemistSupport
  with Gradients {
  override def main(): Any = {
    // Access to node state through "molecule"
    val source = if(node.has("test")) node.get[Int]("test") else 1
    // An aggregate operation
    val g = classicGradient(mid == program)
    // Write access to node state
    node.put("g", g)
    // Return value of the program
    g
  }
}
```

## On this version and past versions

I will try to keep this repository aligned with the latest versions of scafi and Alchemist.

However, I have also set up different branches to "freeze" particular project configurations that have proven to work.
These can be checked out through the usual git branch mechanism, e.g.:

`git checkout scafi-0.3.2-alchemist-9.2.1`

Available branches/configurations:

- `scafi-0.3.2-alchemist-9.2.1`
- `scafi-0.3.3-alchemist-11.3.0`

-->
