# Learning simulations with ScaFi-Alchemist

* [ScaFi](https://scafi.github.io) is an aggregate programming framework
* [Alchemist](https://alchemistsimulator.github.io) is a flexible (meta-)simulator for multi-agent systems

## Alchemist

### Conceptual model

- **Molecule**: name of a data item
- **Concentration**: value associated to a particular molecule
- **Node**: a container of molecules/reactions, living inside an environment
- **Environment**: the Alchemist abstration for the space.
    - It is a container for nodes, and it is able to tell:
  a) Where the nodes are in the space - i.e. their position
  b) How distant are two nodes
  c) Optionally, it may provide support for moving nodes
- **Linking rule**: a function of the current status of the environment that associates to each node a
  neighborhood
    - **Neighborhood**: an entity composed by a node (centre) + a set of nodes (neighbors)
- **Reaction**: any event that can change (through an **action**) the state of the environment
    - Consists of 0+ **conditions**, 1+ **actions**, and a **time distribution**
    - Conditions, time distribution, static rate, and rate equation affect the **frequency** of the reaction
- Alchemist implements an optimised version (NRM) of Gillespie's Stochastic Simulation Algorithm (SSA)

So

- The **system state** depends on the configuration of molecules floating in it
- The **system evolution** depends on the kinds of chemical reactions applicable over time

Another key concept is the **dependency graph**

- Actions are outputs
- Conditions are inputs

### Running simulations

Use task configured in `build.gradle.kts`:

```bash
$ ./gradlew runHelloScafi
```

To run all the (graphic) simulations defined in src/main/yaml type:

```bash
$ ./gradlew runAll
```
To run the simulation in batch (e.g, to produce data for plots) you can type:
```bash
$ ./gradlew runAll -Pbatch=true -Pvariables=random
```


Finally, you can produce plots from the data generated by Alchemist simulation.
This repository contains a highly configurable script (please look to the configuration defined in [plots](/plots)).

To run the script, you should run:
```bash
$ python plotter.py plots/helloworld.yml ./build/exports/helloScafi ".*" "result" plots/ 
```

Where:
- the first argument is the plot configuration (expressed using a yaml file)
- the second argument is where the files are located 
- the third argument is a regex used to select the simulations file
- the fourth argument defines the initial names of the plot
- the last argument devises the folder in which the plots will be stored
### Scafi

The simulation descriptor must indicate `incarnation: scafi`
 and configure a `RunScafiProgram` action
 pointing to the class of some class implementing `AggregateProgram`.

```yaml
incarnation: scafi

_reactions:
  - program: &program
    - time-distribution:
        type: ExponentialTime
        parameters: [1]
      type: Event
      actions:
        - type: RunScafiProgram
          parameters: [it.unibo.casestudy.HelloWorld, 5.0] # second argument is retention time
    - program: send
```
An example ScaFi program is the following

```scala
package it.unibo.casestudy

import it.unibo.alchemist.model.implementations.molecules.SimpleMolecule
import it.unibo.alchemist.model.scafi.ScafiIncarnationForAlchemist._

class HelloWorld extends AggregateProgram with StandardSensors with ScafiAlchemistSupport
  with Gradients {
  override def main(): Any = {
    // Access to node state through "molecule"
    val source = if(node.has("test")) node.get[Int]("test") else 1
    // An aggregate operation
    val g = classicGradient(mid == program)
    // Write access to node state
    node.put("g", g)
    // Return value of the program
    g
  }
}
```
